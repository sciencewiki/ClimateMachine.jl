<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heat Equation · CLIMA</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.svg" alt="CLIMA logo"/></a><div class="docs-package-name"><span class="docs-autofit">CLIMA</span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><a class="tocitem" href="../../../../Installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Atmos/heldsuarez/">Dry Idealized GCM</a></li><li><a class="tocitem" href="../../../../ExtendingCLIMA/Atmos/Model/risingbubble/">Rising Bubble LES</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3-1"><span class="docs-label">Heat</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Heat Equation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Preliminary-configuration-1"><span>Preliminary configuration</span></a></li><li><a class="tocitem" href="#Loading-code-1"><span>Loading code</span></a></li><li><a class="tocitem" href="#Initialization-1"><span>Initialization</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><span>Define the set of Partial Differential Equations (PDEs)</span></a></li><li class="toplevel"><a class="tocitem" href="#Spatial-discretization-1"><span>Spatial discretization</span></a></li><li class="toplevel"><a class="tocitem" href="#Time-discretization-1"><span>Time discretization</span></a></li><li><a class="tocitem" href="#Initialize-the-state-vector-1"><span>Initialize the state vector</span></a></li><li><a class="tocitem" href="#Initialize-the-ODE-solver-1"><span>Initialize the ODE solver</span></a></li><li><a class="tocitem" href="#Inspect-the-initial-conditions-1"><span>Inspect the initial conditions</span></a></li><li class="toplevel"><a class="tocitem" href="#Solver-hooks-/-callbacks-1"><span>Solver hooks / callbacks</span></a></li><li class="toplevel"><a class="tocitem" href="#Solve-1"><span>Solve</span></a></li><li class="toplevel"><a class="tocitem" href="#Post-processing-1"><span>Post-processing</span></a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-4-1" type="checkbox"/><label class="tocitem" for="menuitem-3-4-1"><span class="docs-label">LinearSolvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Numerics/LinearSolvers/cg/">Conjugate Gradient</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../literate_markdown/">Notes on Literate</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Extending CLIMA</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Contributing/CONTRIBUTING/">Home</a></li><li><span class="tocitem">Arrays</span></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Common/SurfaceFluxes/">SurfaceFluxes</a></li><li><a class="tocitem" href="../../../../ExtendingCLIMA/Common/MoistThermodynamics/">MoistThermodynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../../ExtendingCLIMA/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../../ExtendingCLIMA/Atmos/Model/turbulence/">Turbulence</a></li><li><a class="tocitem" href="../../../../ExtendingCLIMA/Atmos/Model/tracers/">Tracers</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Diagnostics/DiagnosticVariables/">Variables</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><span class="tocitem">Meshes</span></li><li><input class="collapse-toggle" id="menuitem-4-8-2" type="checkbox"/><label class="tocitem" for="menuitem-4-8-2"><span class="docs-label">DG methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Numerics/DGmethods/how_to_make_a_balance_law/">How to make a balance law</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8-3" type="checkbox"/><label class="tocitem" for="menuitem-4-8-3"><span class="docs-label">ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Numerics/ODESolvers/Timestepping/">Time-integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8-4" type="checkbox"/><label class="tocitem" for="menuitem-4-8-4"><span class="docs-label">Linear Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../ExtendingCLIMA/Numerics/LinearSolvers/IterativeSolvers/">Iterative Solvers</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/">Home</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../../APIs/Atmos/Microphysics/">Microphysics</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/Common/SurfaceFluxes/">Surface Fluxes</a></li></ul></li><li><a class="tocitem" href="../../../../APIs/Arrays/Arrays/">Arrays</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/Diagnostics/Diagnostics/">List of variables</a></li><li><a class="tocitem" href="../../../../APIs/Diagnostics/InputOutput/">Input/Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/Numerics/Meshes/Mesh/">Meshes</a></li><li><a class="tocitem" href="../../../../APIs/Numerics/LinearSolvers/LinearSolvers/">LinearSolvers</a></li><li><a class="tocitem" href="../../../../APIs/Numerics/ODESolvers/ODESolvers/">ODESolvers</a></li><li><a class="tocitem" href="../../../../APIs/Numerics/DGmethods/BalanceLawOverview/">Balance Law</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Theory &amp; design philosophy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Discussions/">Home</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Discussions/Atmos/EDMFEquations/">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../CodingConventions/">Coding Conventions</a></li><li><a class="tocitem" href="../../../../AcceptableUnicode/">Acceptable Unicode characters</a></li><li><a class="tocitem" href="../../../../VariableList/">CliMA Variable List</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Land</a></li><li><a class="is-disabled">Heat</a></li><li class="is-active"><a href>Heat Equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heat Equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/climate-machine/CLIMA/blob/master/tutorials/Land/Heat/heat_equation.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Heat-equation-tutorial-1"><a class="docs-heading-anchor" href="#Heat-equation-tutorial-1">Heat equation tutorial</a><a class="docs-heading-anchor-permalink" href="#Heat-equation-tutorial-1" title="Permalink"></a></h1><p>In this tutorial, we&#39;ll be solving the <a href="https://en.wikipedia.org/wiki/Heat_equation">heat equation</a>:</p><p><span>$\frac{∂ T}{∂ t} + ∇ ⋅ (-α ∇T) = 0$</span></p><p>where</p><ul><li><code>α</code> is the thermal diffusivity</li><li><code>T</code> is the temperature (the unknown we&#39;re solving for)</li></ul><p>To put this in the form of CLIMA&#39;s <a href="generated/Land/Heat/@ref CLIMA.DGMethods.BalanceLaw"><code>BalanceLaw</code></a>, we&#39;ll re-write the equation as:</p><p><span>$\frac{∂ T}{∂ t} + ∇ ⋅ (F(T,t)) = 0$</span></p><p>where</p><ul><li><code>F(T,t) = -α ∇T</code> is the diffusive flux</li></ul><p>with boundary conditions</p><ul><li>Fixed temperature <code>T_surface</code> at z_{min} (non-zero Dirichlet)</li><li>No thermal flux at z_{min} (zero Neumann)</li></ul><p>Solving these equations is broken down into the following steps:</p><ul><li><ol><li>Preliminary configuration</li></ol></li><li><ol><li>PDEs</li></ol></li><li><ol><li>Space discretization</li></ol></li><li><ol><li>Time discretization</li></ol></li><li><ol><li>Solver hooks / callbacks</li></ol></li><li><ol><li>Solve</li></ol></li><li><ol><li>Post-processing</li></ol></li></ul><h1 id="Preliminary-configuration-1"><a class="docs-heading-anchor" href="#Preliminary-configuration-1">Preliminary configuration</a><a class="docs-heading-anchor-permalink" href="#Preliminary-configuration-1" title="Permalink"></a></h1><h2 id="Loading-code-1"><a class="docs-heading-anchor" href="#Loading-code-1">Loading code</a><a class="docs-heading-anchor-permalink" href="#Loading-code-1" title="Permalink"></a></h2><p>First, we&#39;ll load our pre-requisites</p><ul><li>load external packages:</li></ul><pre><code class="language-">using MPI
using Test
using Logging
using Printf
using NCDatasets
using LinearAlgebra
using OrderedCollections
using Interpolations
using DelimitedFiles
using Plots
using StaticArrays</code></pre><ul><li>load necessary CLIMA modules:</li></ul><pre><code class="language-julia">using CLIMA
using CLIMA.Mesh.Topologies
using CLIMA.Mesh.Grids
using CLIMA.Writers
using CLIMA.VTK
using CLIMA.Mesh.Elements: interpolationmatrix
using CLIMA.DGmethods
using CLIMA.DGmethods.NumericalFluxes
using CLIMA.DGmethods: BalanceLaw, LocalGeometry
using CLIMA.MPIStateArrays
using CLIMA.GenericCallbacks: EveryXWallTimeSeconds, EveryXSimulationSteps
using CLIMA.GenericCallbacks
using CLIMA.ODESolvers
using CLIMA.VariableTemplates</code></pre><ul><li>import necessary CLIMA modules: (<code>import</code> indicates that we must provide implementations of these structs/methods)</li></ul><pre><code class="language-julia">import CLIMA.DGmethods: vars_state_auxiliary,
                        vars_state_conservative,
                        vars_state_gradient,
                        vars_state_gradient_flux,
                        source!,
                        flux_second_order!,
                        flux_first_order!,
                        compute_gradient_argument!,
                        compute_gradient_flux!,
                        update_aux!,
                        nodal_update_aux!,
                        init_state_auxiliary!,
                        init_state_conservative!,
                        boundary_state!</code></pre><pre><code class="language-none">WARNING: could not import DGmethods.update_aux! into ex-heat_equation
WARNING: could not import DGmethods.nodal_update_aux! into ex-heat_equation</code></pre><h2 id="Initialization-1"><a class="docs-heading-anchor" href="#Initialization-1">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-1" title="Permalink"></a></h2><p>Define the float type (<code>Float64</code> or <code>Float32</code>)</p><pre><code class="language-julia">FT = Float64;</code></pre><p>Initialize CLIMA for CPU.</p><pre><code class="language-julia">CLIMA.init(; disable_gpu=true);</code></pre><p>Load some helper functions (soon to be incorporated into <code>CLIMA/src</code>)</p><pre><code class="language-julia">include(joinpath(&quot;..&quot;,&quot;helper_funcs.jl&quot;))
include(joinpath(&quot;..&quot;,&quot;plotting_funcs.jl&quot;))</code></pre><pre><code class="language-none">export_plot_snapshot (generic function with 1 method)</code></pre><h1 id="Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><a class="docs-heading-anchor" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1">Define the set of Partial Differential Equations (PDEs)</a><a class="docs-heading-anchor-permalink" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1" title="Permalink"></a></h1><p>Model parameters can be stored in the particular <a href="generated/Land/Heat/@ref CLIMA.DGMethods.BalanceLaw"><code>BalanceLaw</code></a>, in this case, a <code>HeatModel</code>:</p><pre><code class="language-julia">Base.@kwdef struct HeatModel{FT} &lt;: BalanceLaw
  &quot;Heat capacity&quot;
  ρc::FT = 1
  &quot;Thermal diffusivity&quot;
  α::FT = 0.01
  &quot;Initial conditions for temperature&quot;
  initialT::FT = 295.15
  &quot;Surface boundary value for temperature (Dirichlet boundary conditions)&quot;
  surfaceT::FT = 300.0
end</code></pre><p>Create an instance of the <code>HeatModel</code>:</p><pre><code class="language-julia">m = HeatModel{FT}();</code></pre><p>All of the methods defined below, in this section, were <code>import</code>ed in <a href="#Loading-code-1">Loading code</a>, and we must provide our own implementation as these methods are called inside <code>solve!</code>. Each of these methods have a fall-back of &quot;do nothing&quot; if we don&#39;t, or fail to, implement these methods after <code>import</code>ing.</p><p>Specify auxiliary variables for <code>HeatModel</code> (stored in <code>aux</code>)</p><pre><code class="language-julia">vars_state_auxiliary(::HeatModel, FT) = @vars(z::FT, T::FT);</code></pre><p>Specify state variables, the variables solved for in the PDEs, for <code>HeatModel</code> (stored in <code>Q</code>)</p><pre><code class="language-julia">vars_state_conservative(::HeatModel, FT) = @vars(ρcT::FT);</code></pre><p>Specify state variables whose gradients are needed for <code>HeatModel</code></p><pre><code class="language-julia">vars_state_gradient(::HeatModel, FT) = @vars(T::FT);</code></pre><p>Specify gradient variables for <code>HeatModel</code></p><pre><code class="language-julia">vars_state_gradient_flux(::HeatModel, FT) = @vars(∇T::SVector{3,FT});</code></pre><p>Specify the initial values in <code>aux::Vars</code>, which are available in <code>init_state_conservative!</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>aux.z</code> and <code>aux.T</code> are available here because we&#39;ve specified <code>z</code> and <code>T</code> in <code>vars_state_auxiliary</code></li></ul><pre><code class="language-julia">function init_state_auxiliary!(m::HeatModel, aux::Vars, geom::LocalGeometry)
  aux.z = geom.coord[3]
  aux.T = m.initialT
end;</code></pre><p>Specify the initial values in <code>state::Vars</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>state.ρcT</code> is available here because we&#39;ve specified <code>ρcT</code> in <code>vars_state_conservative</code></li></ul><pre><code class="language-julia">function init_state_conservative!(m::HeatModel, state::Vars, aux::Vars, coords, t::Real)
  state.ρcT = m.ρc * aux.T
end;</code></pre><p>The remaining methods, defined in this section, are called at every time-step in the solver by the <a href="generated/Land/Heat/@ref CLIMA.DGMethods.BalanceLaw"><code>BalanceLaw</code></a> framework.</p><p>Overload <code>update_aux!</code> to call <code>soil_nodal_update_aux!</code>, or any other auxiliary methods</p><pre><code class="language-julia">function update_aux!(dg::DGModel, m::HeatModel, Q::MPIStateArray, t::Real, elems::UnitRange)
  nodal_update_aux!(soil_nodal_update_aux!, dg, m, Q, t, elems)
  return true # TODO: remove return true
end;</code></pre><p>Compute/update all auxiliary variables at each node. Note that</p><ul><li><code>aux.T</code> is available here because we&#39;ve specified <code>T</code> in <code>vars_state_auxiliary</code></li></ul><pre><code class="language-julia">function soil_nodal_update_aux!(m::HeatModel, state::Vars, aux::Vars, t::Real)
  aux.T = state.ρcT / m.ρc
end;</code></pre><p>Since we have diffusive fluxes, we must tell CLIMA to compute the gradient of <code>T</code>. Here, we specify how <code>T</code> is computed. Note that</p><ul><li><code>transform.T</code> is available here because we&#39;ve specified <code>T</code> in <code>vars_state_gradient</code></li></ul><pre><code class="language-julia">function compute_gradient_argument!(m::HeatModel, transform::Vars, state::Vars, aux::Vars, t::Real)
  transform.T = state.ρcT / m.ρc
end;</code></pre><p>Specify where in <code>diffusive::Vars</code> to store the computed gradient in <code>compute_gradient_argument!</code>. Note that:</p><ul><li><code>diffusive.∇T</code> is available here because we&#39;ve specified <code>∇T</code> in <code>vars_state_gradient_flux</code></li><li><code>∇transform.T</code> is available here because we&#39;ve specified <code>T</code>  in <code>vars_state_gradient</code></li></ul><pre><code class="language-julia">function compute_gradient_flux!(m::HeatModel, diffusive::Vars, ∇transform::Grad, state::Vars, aux::Vars, t::Real)
  diffusive.∇T = ∇transform.T
end;</code></pre><p>We do no have sources, nor non-diffusive fluxes.</p><pre><code class="language-julia">function source!(m::HeatModel, _...); end;
function flux_first_order!(m::HeatModel, _...); end;</code></pre><p>Compute diffusive flux (<span>$F(T,t) = -α ∇T$</span> in the original PDE). Note that:</p><ul><li><code>diffusive.∇T</code> is available here because we&#39;ve specified <code>∇T</code> in <code>vars_state_gradient_flux</code></li></ul><pre><code class="language-julia">function flux_second_order!(m::HeatModel, flux::Grad, state::Vars, diffusive::Vars, hyperdiffusive::Vars, aux::Vars, t::Real)
   flux.ρcT -= m.α * diffusive.∇T
end;</code></pre><h3 id="Boundary-conditions-1"><a class="docs-heading-anchor" href="#Boundary-conditions-1">Boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions-1" title="Permalink"></a></h3><p>Boundary conditions are specified for diffusive and non-diffusive terms</p><p>The boundary conditions for <code>ρcT</code> are specified here for non-diffusive terms</p><pre><code class="language-julia">function boundary_state!(nf, m::HeatModel, state⁺::Vars, aux⁺::Vars,
                         nM, state⁻::Vars, aux⁻::Vars, bctype, t, _...)
  if bctype == 1 # surface
    state⁺.ρcT = m.ρc * m.surfaceT
  elseif bctype == 2 # bottom
    nothing
  end
end;</code></pre><p>The boundary conditions for <code>ρcT</code> are specified here for diffusive terms</p><pre><code class="language-julia">function boundary_state!(nf, m::HeatModel, state⁺::Vars, diff⁺::Vars,
                         aux⁺::Vars, nM, state⁻::Vars, diff⁻::Vars, aux⁻::Vars,
                         bctype, t, _...)
  if bctype == 1 # surface
    state⁺.ρcT = m.ρc * m.surfaceT
  elseif bctype == 2 # bottom
    diff⁺.∇T = -diff⁻.∇T
  end
end;</code></pre><h1 id="Spatial-discretization-1"><a class="docs-heading-anchor" href="#Spatial-discretization-1">Spatial discretization</a><a class="docs-heading-anchor-permalink" href="#Spatial-discretization-1" title="Permalink"></a></h1><p>Prescribe vector of vertical elements (in meters)</p><pre><code class="language-julia">velems = collect(0:10) / 10;</code></pre><p>Prescribe polynomial order of basis functions in finite elements</p><pre><code class="language-julia">N_poly = 5;</code></pre><p>Define topology (i.e., element connectivity)</p><pre><code class="language-julia">topl = StackedBrickTopology(
  MPI.COMM_WORLD,
  (0.0:1,0.0:1,velems);
  periodicity = (true,true,false),
  boundary=((0,0),(0,0),(1,2)));</code></pre><p>Define grid, based on topology</p><pre><code class="language-julia">grid = DiscontinuousSpectralElementGrid(
  topl,
  FloatType = FT,
  DeviceArray = Array,
  polynomialorder = N_poly);</code></pre><p>Configure the Discontinuous Galerkin (DG) model, based on the PDEs, grid and penalty terms</p><pre><code class="language-">dg = DGModel(
  m,
  grid,</code></pre><p>penalty terms for discretizations:</p><pre><code class="language-julia">  CentralNumericalFluxFirstOrder(),
  CentralNumericalFluxSecondOrder(),
  CentralNumericalFluxGradient())</code></pre><h1 id="Time-discretization-1"><a class="docs-heading-anchor" href="#Time-discretization-1">Time discretization</a><a class="docs-heading-anchor-permalink" href="#Time-discretization-1" title="Permalink"></a></h1><p>We&#39;ll define the time-step based on the <a href="https://en.wikipedia.org/wiki/Fourier_number">Fourier number</a></p><pre><code class="language-julia">Δ = min_node_distance(grid)

given_Fourier = 0.08;
Fourier_bound = given_Fourier*Δ^2 / m.α;
dt = Fourier_bound</code></pre><pre><code class="language-none">0.0011039800162777238</code></pre><h2 id="Initialize-the-state-vector-1"><a class="docs-heading-anchor" href="#Initialize-the-state-vector-1">Initialize the state vector</a><a class="docs-heading-anchor-permalink" href="#Initialize-the-state-vector-1" title="Permalink"></a></h2><p>This initializes the state vector and allocates memory for the solution in space (<code>dg</code> has the model <code>m</code>, which describes the PDEs as well as the function used for initialization):</p><pre><code class="language-">Q = init_ode_state(dg, Float64(0))</code></pre><h2 id="Initialize-the-ODE-solver-1"><a class="docs-heading-anchor" href="#Initialize-the-ODE-solver-1">Initialize the ODE solver</a><a class="docs-heading-anchor-permalink" href="#Initialize-the-ODE-solver-1" title="Permalink"></a></h2><p>Here, we use an explicit Low-Storage <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a> method</p><pre><code class="language-">lsrk = LSRK54CarpenterKennedy(dg, Q; dt = dt, t0 = 0);
nothing #hide</code></pre><h2 id="Inspect-the-initial-conditions-1"><a class="docs-heading-anchor" href="#Inspect-the-initial-conditions-1">Inspect the initial conditions</a><a class="docs-heading-anchor-permalink" href="#Inspect-the-initial-conditions-1" title="Permalink"></a></h2><p>Let&#39;s export a plot of the initial state output_dir = joinpath(dirname(dirname(pathof(CLIMA))), &quot;output&quot;, &quot;land&quot;);</p><pre><code class="language-">output_dir = joinpath(@__DIR__);
output_dir = pwd();
mkpath(output_dir)

state_vars = get_vars_from_stack(grid, Q, m, vars_state_conservative)
aux_vars = get_vars_from_stack(grid, dg.state_auxiliary, m, vars_state_auxiliary)
all_vars = OrderedDict(state_vars..., aux_vars...)
export_plot_snapshot(all_vars, (&quot;ρcT&quot;,), joinpath(output_dir, &quot;initial_condition.png&quot;))</code></pre><p><img src="initial_condition.png" alt/></p><p>It matches what we have in <code>init_state_conservative!(m::HeatModel, ...)</code>, so let&#39;s continue.</p><h1 id="Solver-hooks-/-callbacks-1"><a class="docs-heading-anchor" href="#Solver-hooks-/-callbacks-1">Solver hooks / callbacks</a><a class="docs-heading-anchor-permalink" href="#Solver-hooks-/-callbacks-1" title="Permalink"></a></h1><p>Define simulation time (all units are SI) and number of outputs over this interval</p><pre><code class="language-julia">const timeend = 40;
const n_outputs = 5;</code></pre><p>This equates to exports every ceil(Int, timeend/n_outputs) time-step:</p><pre><code class="language-julia">const every_x_simulation_time = ceil(Int, timeend/n_outputs);</code></pre><p>Create a dictionary for <code>z</code> coordinate (and convert to cm) NCDatasets IO:</p><pre><code class="language-">z_scale = 100 # convert from meters to cm
dims = OrderedDict(&quot;z&quot; =&gt; collect(get_z(grid, z_scale)))</code></pre><p>Create a DataFile, which is callable to get the name of each file given a step</p><pre><code class="language-julia">output_data = DataFile(joinpath(output_dir, &quot;output_data&quot;))</code></pre><pre><code class="language-none">Main.ex-heat_equation.DataFile{String}(&quot;/home/runner/work/CLIMA/CLIMA/docs/build/generated/Land/Heat/output_data&quot;, &quot;num&quot;)</code></pre><p>CLIMA&#39;s time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, the state and aux variables are collected, combined into a single <code>OrderedDict</code> and written to a NetCDF file (for each output step <code>step</code>).</p><pre><code class="language-">step = [0]
callback = GenericCallbacks.EveryXSimulationTime(every_x_simulation_time, lsrk) do (init = false)
  state_vars = get_vars_from_stack(grid, Q, m, vars_state_conservative; exclude=[])
  aux_vars = get_vars_from_stack(grid, dg.state_auxiliary, m, vars_state_auxiliary; exclude=[&quot;z&quot;])
  all_vars = OrderedDict(state_vars..., aux_vars...)
  write_data(NetCDFWriter(), output_data(step[1]), dims, all_vars, gettime(lsrk))
  step[1]+=1
  nothing
end</code></pre><h1 id="Solve-1"><a class="docs-heading-anchor" href="#Solve-1">Solve</a><a class="docs-heading-anchor-permalink" href="#Solve-1" title="Permalink"></a></h1><p>This is the main &quot;solve&quot; method call. While users do not have access to the time-stepping loop, code and function calls may be injected via <code>callbacks</code> keyword argument, which is a <code>Tuple</code> of <a href="generated/Land/Heat/@ref"><code>GenericCallbacks</code></a>.</p><pre><code class="language-">solve!(Q, lsrk; timeend=timeend, callbacks=(callback,))</code></pre><h1 id="Post-processing-1"><a class="docs-heading-anchor" href="#Post-processing-1">Post-processing</a><a class="docs-heading-anchor-permalink" href="#Post-processing-1" title="Permalink"></a></h1><p>Our solution has now been calculated and exported to NetCDF files in <code>output_dir</code>. Let&#39;s collect them all into a dictionary whose keys are output interval and values of NCDataset&#39;s:</p><pre><code class="language-julia">all_data = collect_data(output_data, step[1])</code></pre><pre><code class="language-none">Dict{Any,Any} with 0 entries</code></pre><p>To get <code>T</code> at time-step 0, we can use <code>T_at_t_0 = all_data[0][&quot;T&quot;][:]</code></p><p>Let&#39;s plot the solution:</p><pre><code class="language-">export_plot(all_data, (&quot;ρcT&quot;,), joinpath(output_dir, &quot;solution_vs_time.png&quot;))</code></pre><p><img src="solution_vs_time.png" alt/></p><p>The results look as we would expect: a fixed temperature at the bottom is resulting in heat flux that propagates up the domain. To run this file, and inspect the solution in <code>all_data</code>, include this tutorial in the Julia REPL with:</p><pre><code class="language-julia">include(joinpath(&quot;tutorials&quot;, &quot;Land&quot;, &quot;Heat&quot;, &quot;heat_equation.jl&quot;))</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../../ExtendingCLIMA/Atmos/Model/risingbubble/">« Rising Bubble LES</a><a class="docs-footer-nextpage" href="../../../Numerics/LinearSolvers/cg/">Conjugate Gradient »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 April 2020 18:25">Thursday 30 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
